import ts = require("typescript")
import util = require("util")
let commander = require("commander")
let error = require('commander.js-error')

commander
	.version("0.0.1")
	.option('-q, --quiet', 'Suppress warnings')
	.option('--debugPrefix [prefix]', 'Print additional information for symbols starting with...')
	.option('--debugVerbose', 'Dump entire object when printing debug information')
	.arguments("<file>")
	.parse(process.argv)

if (commander.args.length < 1)
	error("No file specified")

if (commander.args.length > 1)
	error("Too many files specified, at the moment the limit is 1")

let program = ts.createProgram(commander.args, {})

let sourceFiles = program.getSourceFiles()

if (sourceFiles.length <= 1)
	error("File not found")

let typeChecker = program.getTypeChecker()

console.log("# Generated by dts2nim script")
console.log("# Source files:")
for (let sourceFile of sourceFiles) {
	console.log("#     " + sourceFile.fileName)
}

console.log()
console.log("when not defined(js) and not defined(Nimdoc):")
console.log("  {.error: \"This module only works on the JavaScript platform\".}")
console.log()

// Support

// Assume enum is a bitfield, print all relevant bits.
// If "tight", assume enum values are exact values, not masks.
function enumBitstring(Enum, value:number, tight = false) : string {
	let result = ""
	for (let key in Enum) {
		let bit = Enum[key]
		if (typeof bit != "number" || !bit) continue
		let masked = value&bit
		if (tight ? (masked==bit) : masked) {
			if (result) result += "+"
			result += key
		}
	}
	return result
}

function hasBit(a:number, b:number) { return (a&b)==b }

class UnusableType extends Error {
	type: ts.Type
	constructor(type: ts.Type) {
		super("Cannot represent type: " + typeChecker.typeToString(type))
		this.type = type
	}
}

function nimType(type: ts.Type) : string {
	if (type.flags & ts.TypeFlags.Number)
		return "float"
	throw new UnusableType(type)
}

let warn = commander.quiet ? function (...X) {} : console.warn.bind(console)

function linePrefix(str:string, prefix:string, startAtLine = 0) : string {
	let ary = str.split("\n")
	for (let idx in ary) {
		if (+idx >= startAtLine)
			ary[idx] = prefix + ary[idx]
	}
	return ary.join("\n")
}

function debugVerboseEpilogue(obj:any) : string {
	if (!commander.debugVerbose)
		return ""
	return ", " + linePrefix(util.inspect(obj), "#         ", 1)
}

// Emit symbols
let sourceFile = sourceFiles[sourceFiles.length-1]

for (let sym of typeChecker.getSymbolsInScope(sourceFile.endOfFileToken, 0xFFFFFFFF)) {
	let type = typeChecker.getTypeOfSymbolAtLocation(sym, sourceFile.endOfFileToken)
	
	if (commander.debugPrefix && sym.name.substr(0, commander.debugPrefix.length) == commander.debugPrefix)
		console.log("\n# " + sym.name +
			"\n#     Node:" + enumBitstring(ts.SymbolFlags, sym.flags, true) +
			debugVerboseEpilogue(sym) +
			"\n#     Type:" + enumBitstring(ts.TypeFlags, type.flags, true) +
			debugVerboseEpilogue(type)
		)

	if (hasBit(sym.flags, ts.SymbolFlags.BlockScopedVariable)) {
		try {
			let typeString = nimType(type)
			console.log("var " + sym.name + "* {.importc, nodecl.}: " + typeString)
		} catch (e) {
			if (e instanceof UnusableType)
				warn("Could not translate variable "+sym.name+" because couldn't translate type "+typeChecker.typeToString(e.type))
			else
				throw e
		}
	} else {
		warn("Could not figure out how to translate symbol", sym.name, ":",
				typeChecker.typeToString(type))
	}
}

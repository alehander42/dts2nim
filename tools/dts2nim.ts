// Takes an input ts file, converts types in final scope to Nim and outputs Nim file to stdout

import ts = require("typescript")
import util = require("util")
let commander = require("commander")
let error = require('commander.js-error')

commander
	.version("0.0.1")
	.option('-q, --quiet', 'Suppress warnings')
	.option('--debugPrefix [prefix]', 'Print additional information for symbols starting with...')
	.option('--debugVerbose', 'Dump entire object when printing debug information')
	.arguments("<file>")
	.parse(process.argv)

if (commander.args.length < 1)
	error("No file specified")

if (commander.args.length > 1)
	error("Too many files specified, at the moment the limit is 1")

let program = ts.createProgram(commander.args, {})

let sourceFiles = program.getSourceFiles()

if (sourceFiles.length <= 1)
	error("File not found")

let typeChecker = program.getTypeChecker()

console.log("# Generated by dts2nim script")
console.log("# Source files:")
for (let sourceFile of sourceFiles) {
	console.log("#     " + sourceFile.fileName)
}

console.log()
console.log("when not defined(js) and not defined(Nimdoc):")
console.log("  {.error: \"This module only works on the JavaScript platform\".}")
console.log()

// Support

// Assume enum is a bitfield, print all relevant bits.
// If "tight", assume enum values are exact values, not masks.
function enumBitstring(Enum, value:number, tight = false) : string {
	let result = ""
	for (let key in Enum) {
		let bit = Enum[key]
		if (typeof bit != "number" || !bit) continue
		let masked = value&bit
		if (tight ? (masked==bit) : masked) {
			if (result) result += "+"
			result += key
		}
	}
	return result
}

// Are all bits in b set in a?
function hasBit(a:number, b:number) { return (a&b)==b }

// Convert TypeScript identifier to legal Nim identifier
// FIXME: Leaves open possibility of collisions
function identifierScrub(id:string) : string {
	return id
		.replace(/_{2,}/, "_")
		.replace(/^_/, "")
}

function needIdentifierScrub(id:string) : boolean {
	return id != identifierScrub(id)
}

// Print {.importc.} with possible symbol correction
function importDirective(id:string, cpp:boolean = false) : string {
	return "importc" + (cpp?"pp":"") + (id != identifierScrub(id) ? ":\"" + id + "\"" : "")
}

function capitalizeFirstLetter(str:string) : string {
	return str.charAt(0).toUpperCase() + str.slice(1)
}


// Exceptions

// Raised on Typescript type the converter script doesn't know how to convert
class UnusableType extends Error {
	constructor(public type: ts.Type) {
		super("Cannot represent type: " + typeChecker.typeToString(type))
	}
}

class GenConstructFail extends Error {
}

// Generator classes

// There is a series of Gen types which represent type items and know how to convert them to strings.
// There is also a vendor (a factory) which knows how to create the Gen types given TypeScript objects.
// The Gen constructors should take "pre-digested" data and do very little. Error checking should be
// done in the vendor, not in the Gen.
// If output types other than Nim are at some point supported, the gens will need to be subclassed,
// and the vendor may or may not need to be significantly subclassed.

interface GenVendor {
	typeGen(tsType: ts.Type)
}

interface Gen {
	declString() : string
}

function genJoin(a:Gen[], joiner:string) {
	return a.map(g => g.declString()).join(joiner)
}

function decls(a: Gen[])  { return genJoin(a, "\n") }
function params(a: Gen[]) { return genJoin(a, ", ") }

function genJoinPrefixed(a:Gen[], prefix:string) {
	return a.map(g => prefix + g.declString()).join("")
}

interface TypeGen extends Gen {
	typeString() : string
}

class IdentifierGen {
	constructor(public name:string, public type: TypeGen) {}
}

class VariableGen extends IdentifierGen implements Gen {
	declString() : string {
		return `var ${identifierScrub(this.name)}* {.${importDirective(this.name)}, nodecl.}: `
		     + this.type.typeString()
	}
}

class ParameterGen extends IdentifierGen implements Gen {
	declString() : string {
		return `${identifierScrub(this.name)}: ${this.type.typeString()}`
	}
}

class FieldGen extends IdentifierGen implements Gen {
	declString() : string {
		return `${identifierScrub(this.name)}*: ${this.type.typeString()}`
		     + (needIdentifierScrub(this.name) ? ` {.importc:"${this.name}".}` : "")
	}	
}

class SignatureGen implements Gen {
	owner: ClassGen
	constructor(public name: string, public params:ParameterGen[], public returnType: TypeGen) {}
	declString() : string {
		let fullParams = (this.owner ? [new ParameterGen("self", this.owner)] : []) 
		               .concat( this.params )
		return `proc ${identifierScrub(this.name)}*(${params(fullParams)}) : `
		     + this.returnType.typeString()
			 + ` {.${importDirective(this.name, !!this.owner)}.}`
	}
}

class ConstructorGen implements Gen {
	owner: ClassGen
	constructor(public params:ParameterGen[]) {}
	declString() : string {
		let scrubbed = identifierScrub(this.owner.name)
		let name = "new" + capitalizeFirstLetter(scrubbed)
		// Note: params.length check is to work around a bug which is fixed in newest Nim beta
		return `proc ${name}*(${params(this.params)}) : ${scrubbed}`
			 + ` {.importcpp:"new ${this.owner.name}${this.params.length?"(@)":""}".}`
	}
}

class LiteralTypeGen implements TypeGen {
	constructor(public literal: string) {}

	declString() : string { throw new Error("Tried to emit a declaration for a a core type") }
	typeString() { return this.literal }
}

class ClassGen implements TypeGen { // TODO: Make name optional?
	// Inherit may be null
	constructor(public name: string, public inherit:string, public fields: FieldGen[], public constructors: ConstructorGen[], public methods: SignatureGen[]) {
		for (let constructor of constructors)
			constructor.owner = this
		for (let method of methods)
			method.owner = this
	}

	declString() : string {
		let fullMethods = (this.constructors as Gen[]).concat( this.methods )
		return `type ${identifierScrub(this.name)}* {.${importDirective(this.name)}.} = ref object of `
		     + (this.inherit ? this.inherit : "RootObj")
			 + genJoinPrefixed(this.fields, "\n    ")
		     + genJoinPrefixed(fullMethods, "\n")
	}
	typeString() {
		return this.name
	}
}

class GenVendor {
	variableGen(sym: ts.Symbol, tsType: ts.Type) : VariableGen {
		try {
			return new VariableGen(sym.name, vendor.typeGen(tsType))
			
		} catch (_e) {
			let e:{} = _e
			if (e instanceof UnusableType)
				throw new GenConstructFail("Could not translate variable "+sym.name+" because couldn't translate type "+typeChecker.typeToString(e.type))
			else
				throw e
		}
	}

	paramsGen(syms: ts.Symbol[]) : ParameterGen[] {
		return syms.map(sym =>
			new ParameterGen(sym.name, this.typeGen(typeChecker.getTypeOfSymbolAtLocation(sym, sourceFile.endOfFileToken)))
		)
	}

	signatureGen(sym: ts.Symbol, callSignature: ts.Signature) : SignatureGen {
		return new SignatureGen(sym.name, this.paramsGen(callSignature.getParameters()), this.typeGen(callSignature.getReturnType()))
	}

	functionGen(sym: ts.Symbol, tsType: ts.Type) : SignatureGen[] {
		let result: SignatureGen[] = []
		let counter = 0
		for (let callSignature of tsType.getCallSignatures()) {
			try {
				counter++
				result.push( this.signatureGen(sym, callSignature) )
			} catch (e) {
				if (e instanceof UnusableType)
					warn(`Could not translate function ${sym.name}`
						+ (counter > 0 ? `, call signature #${counter}` : "")
						+ ` because tried to translate ${typeChecker.typeToString(tsType)}`
						+ ` but couldn't translate type ${typeChecker.typeToString(e.type)}`
					)
				else
					throw e
			}
		}
		return result
	}

	classGen(tsType: ts.Type) : TypeGen {
		let fields : FieldGen[] = []
		let methods: SignatureGen[] = []
		let constructors: ConstructorGen[] = []
		let foundConstructors = 0
		let sym = tsType.symbol
		let name = sym.name

		// Iterate over class members
		// Public interface for SymbolTable lets you look up keys but not iterate them. CHEAT:
		for (let key in <any>sym.members) {
			let member = sym.members[key]
			let memberType = typeChecker.getTypeOfSymbolAtLocation(member, sourceFile.endOfFileToken)
			
			// Member is a constructor
			if (hasBit(member.flags, ts.SymbolFlags.Constructor)) {
				for (let declaration of member.declarations) {
					foundConstructors++
					try {
						constructors.push( new ConstructorGen( 
							// Parameters exist on Delcaration but are not publicly exposed. CHEAT:
							this.paramsGen( (declaration as any).parameters.map(node => node.symbol) )
						) )
					} catch (_e) {
						let e:{} = _e
						if (e instanceof UnusableType)
							warn(`Could not translate constructor #${foundConstructors} on class ${name}`
							   + ` because couldn't translate type ${typeChecker.typeToString(e.type)}`
							)
						else
							throw _e
					}
				}

			// Member is a field
			} else if (hasBit(member.flags, ts.SymbolFlags.Property)) {
				try {
					fields.push(new FieldGen(member.name, this.typeGen(memberType)))
				} catch (_e) {
					let e:{} = _e
					if (e instanceof UnusableType)
						warn(`Could not translate property ${member.name} on class ${name}`
						  +  `because couldn't translate type ${typeChecker.typeToString(e.type)}`
						)
					else
						throw _e
				}

			// Member is a method
			} else if (hasBit(member.flags, ts.SymbolFlags.Method)) {
				let counter = 0
				for (let callSignature of memberType.getCallSignatures()) {
					try {
						counter++
						methods.push( this.signatureGen(member, callSignature) )
					} catch (_e) {
						let e:{} = _e
						if (e instanceof UnusableType)
							warn(`Could not translate method ${sym.name} on class $name}`
								+ (counter > 0 ? `, call signature #${counter}` : "")
								+ ` because tried to translate ${typeChecker.typeToString(tsType)}`
								+ ` but couldn't translate type ${typeChecker.typeToString(e.type)}`
								)
						else
							throw _e
					}
				}

			// Member is unsupported
			} else {
				warn(`Could not figure out how to translate member ${member.name} of class ${sym.name}`)
			}
		}

		// Get superclass
		// Neither "heritageClauses" nor "types" are exposed. CHEAT: 
		let heritageClauses = (<any>sym.declarations[0]).heritageClauses
		let inherit = heritageClauses ? heritageClauses[0].types[0].expression.text : null

		// Get constructor
		// FIXME: Produces garbage on inherited constructors
		if (!foundConstructors)
			constructors.push(new ConstructorGen([]))

		return new ClassGen(name, inherit, fields, constructors, methods)
	}

	typeGen(tsType: ts.Type) : TypeGen {
		if (tsType.flags & ts.TypeFlags.Number) // FIXME: Numberlike?
			return new LiteralTypeGen("float")
		if (tsType.flags & ts.TypeFlags.String) // FIXME: Stringlike?
			return new LiteralTypeGen("cstring")
		if (tsType.flags & ts.TypeFlags.Void)
			return new LiteralTypeGen("void")
		if ((tsType.flags & ts.TypeFlags.Class) && tsType.symbol)
			return this.classGen(tsType)
		throw new UnusableType(tsType)
	}
}

// Process input

let vendor = new GenVendor()

// Prints to stderr, suppressed if -q option given
let warn = commander.quiet ? function (...X) {} : console.warn.bind(console)

// Prefix `prefix` to every line of `string`, starting at line `startAtLine`
function linePrefix(str:string, prefix:string, startAtLine = 0) : string {
	let ary = str.split("\n")
	for (let idx in ary) {
		if (+idx >= startAtLine)
			ary[idx] = prefix + ary[idx]
	}
	return ary.join("\n")
}

// Return a string containing a commented-out string representation of an object,
// for tacking onto the end of an existing comment line
function debugVerboseEpilogue(obj:any) : string {
	if (!commander.debugVerbose)
		return ""
	return ", " + linePrefix(util.inspect(obj), "#         ", 1)
}

// Emit symbols

let sourceFile = sourceFiles[sourceFiles.length-1]
let generators : Gen[] = []

for (let sym of typeChecker.getSymbolsInScope(sourceFile.endOfFileToken, 0xFFFFFFFF)) {
	let type = typeChecker.getTypeOfSymbolAtLocation(sym, sourceFile.endOfFileToken)
	
	// Handle --debugPrefix command
	if (commander.debugPrefix && sym.name.substr(0, commander.debugPrefix.length) == commander.debugPrefix)
		console.log("\n# " + sym.name + ": " + typeChecker.typeToString(type) +
			"\n#     Node:" + enumBitstring(ts.SymbolFlags, sym.flags, true) +
			debugVerboseEpilogue(sym) +
			"\n#     Type:" + enumBitstring(ts.TypeFlags, type.flags, true) +
			debugVerboseEpilogue(type)
		)

	// Variable
	try {
		if (hasBit(sym.flags, ts.SymbolFlags.BlockScopedVariable)) {
			generators.push( vendor.variableGen(sym, type) )

		// Function
		} else if (hasBit(sym.flags, ts.SymbolFlags.Function)) {
			generators = generators.concat( vendor.functionGen(sym, type) )
		
		// Class
		} else if (hasBit(sym.flags, ts.SymbolFlags.Class)) {
			generators.push( vendor.classGen(type) )

		// Unsupported
		} else {
			warn("Could not figure out how to translate symbol", sym.name, ":",
					typeChecker.typeToString(type))
		}
	} catch (_e) {
		let e:{} = _e
		if (e instanceof GenConstructFail)
			warn(e.message)
		else
			throw e
	}
}

console.log( decls(generators) )

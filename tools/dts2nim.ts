import ts = require("typescript")
import util = require("util")
let commander = require("commander")
let error = require('commander.js-error')

commander
	.version("0.0.1")
	.option('-q, --quiet', 'Suppress warnings')
	.option('--debugPrefix [prefix]', 'Print additional information for symbols starting with...')
	.option('--debugVerbose', 'Dump entire object when printing debug information')
	.arguments("<file>")
	.parse(process.argv)

if (commander.args.length < 1)
	error("No file specified")

if (commander.args.length > 1)
	error("Too many files specified, at the moment the limit is 1")

let program = ts.createProgram(commander.args, {})

let sourceFiles = program.getSourceFiles()

if (sourceFiles.length <= 1)
	error("File not found")

let typeChecker = program.getTypeChecker()

console.log("# Generated by dts2nim script")
console.log("# Source files:")
for (let sourceFile of sourceFiles) {
	console.log("#     " + sourceFile.fileName)
}

console.log()
console.log("when not defined(js) and not defined(Nimdoc):")
console.log("  {.error: \"This module only works on the JavaScript platform\".}")
console.log()

// Support

// Assume enum is a bitfield, print all relevant bits.
// If "tight", assume enum values are exact values, not masks.
function enumBitstring(Enum, value:number, tight = false) : string {
	let result = ""
	for (let key in Enum) {
		let bit = Enum[key]
		if (typeof bit != "number" || !bit) continue
		let masked = value&bit
		if (tight ? (masked==bit) : masked) {
			if (result) result += "+"
			result += key
		}
	}
	return result
}

function hasBit(a:number, b:number) { return (a&b)==b }

class UnusableType extends Error {
	type: ts.Type
	constructor(type: ts.Type) {
		super("Cannot represent type: " + typeChecker.typeToString(type))
		this.type = type
	}
}

function nimType(type: ts.Type) : string {
	if (type.flags & ts.TypeFlags.Number) // FIXME: Numberlike?
		return "float"
	if (type.flags & ts.TypeFlags.String) // FIXME: Stringlike?
		return "cstring"
	if (type.flags & ts.TypeFlags.Void)
		return "void"
	throw new UnusableType(type)
}

let warn = commander.quiet ? function (...X) {} : console.warn.bind(console)

function linePrefix(str:string, prefix:string, startAtLine = 0) : string {
	let ary = str.split("\n")
	for (let idx in ary) {
		if (+idx >= startAtLine)
			ary[idx] = prefix + ary[idx]
	}
	return ary.join("\n")
}

function debugVerboseEpilogue(obj:any) : string {
	if (!commander.debugVerbose)
		return ""
	return ", " + linePrefix(util.inspect(obj), "#         ", 1)
}

// Emit symbols
let sourceFile = sourceFiles[sourceFiles.length-1]

for (let sym of typeChecker.getSymbolsInScope(sourceFile.endOfFileToken, 0xFFFFFFFF)) {
	let type = typeChecker.getTypeOfSymbolAtLocation(sym, sourceFile.endOfFileToken)
	
	if (commander.debugPrefix && sym.name.substr(0, commander.debugPrefix.length) == commander.debugPrefix)
		console.log("\n# " + sym.name + ": " + typeChecker.typeToString(type) +
			"\n#     Node:" + enumBitstring(ts.SymbolFlags, sym.flags, true) +
			debugVerboseEpilogue(sym) +
			"\n#     Type:" + enumBitstring(ts.TypeFlags, type.flags, true) +
			debugVerboseEpilogue(type)
		)

	if (hasBit(sym.flags, ts.SymbolFlags.BlockScopedVariable)) {
		try {
			let typeString = nimType(type)
			console.log("var " + sym.name + "* {.importc, nodecl.}: " + typeString)
		} catch (e) {
			if (e instanceof UnusableType)
				warn("Could not translate variable "+sym.name+" because couldn't translate type "+typeChecker.typeToString(e.type))
			else
				throw e
		}
	} else if (hasBit(sym.flags, ts.SymbolFlags.Function)) {
		let counter = 0
		for (let callSignature of type.getCallSignatures()) {
			try {
				let params = callSignature.getParameters().map(param =>
					""+param.name + ":" + nimType(typeChecker.getTypeOfSymbolAtLocation(param, sourceFile.endOfFileToken))
				)
				let returnType = nimType(callSignature.getReturnType())
				console.log("proc " + sym.name + "*(" + params.join(", ") + "): " + returnType + " {.importc.}")
			} catch (e) {
				if (e instanceof UnusableType)
					warn("Could not translate function " + sym.name +
						(counter > 0 ? ", call signature #" + counter : "") +
						" because tried to translate " + typeChecker.typeToString(type) +
						" but couldn't translate type " + typeChecker.typeToString(e.type)
					)
				else
					throw e
			}
			counter++
		}
	} else if (hasBit(sym.flags, ts.SymbolFlags.Class) && sym.name[0] == 'Q') {
		let fields : string[] = []
		let methods: string[] = []

		// Public interface for SymbolTable lets you look up keys but not iterate them. Cheat:
		for (let key in <any>sym.members) {
			let member = sym.members[key]
			let memberType = typeChecker.getTypeOfSymbolAtLocation(member, sourceFile.endOfFileToken)
			if (hasBit(member.flags, ts.SymbolFlags.Property)) {
				try {
					let typeString = nimType(memberType)
					fields.push(member.name + "*: " + typeString)
				} catch (e) {
					if (e instanceof UnusableType)
						warn("Could not translate property " + member.name + " on class " + sym.name +
							" because couldn't translate type " + typeChecker.typeToString(memberType)
						)
					else
						throw e
				}
			} else if (hasBit(member.flags, ts.SymbolFlags.Method)) {
				console.log("# Skipping method " + member.name)
			} else {
				warn("Could not figure out how to translate member", member.name, "of class", sym.name)
			}
		}
		console.log("type "+sym.name+"* {.importc.} = object of RootObj" +
			fields.map(field => "\n    " + field).join(""))
	} else {
		warn("Could not figure out how to translate symbol", sym.name, ":",
				typeChecker.typeToString(type))
	}
}

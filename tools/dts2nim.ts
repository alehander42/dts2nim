// Takes an input ts file, converts types in final scope to Nim and outputs Nim file to stdout

import ts = require("typescript")
import util = require("util")
let commander = require("commander")
let error = require('commander.js-error')

commander
	.version("0.0.1")
	.option('-q, --quiet', 'Suppress warnings')
	.option('--debugPrefix [prefix]', 'Print additional information for symbols starting with...')
	.option('--debugVerbose', 'Dump entire object when printing debug information')
	.arguments("<file>")
	.parse(process.argv)

if (commander.args.length < 1)
	error("No file specified")

if (commander.args.length > 1)
	error("Too many files specified, at the moment the limit is 1")

let program = ts.createProgram(commander.args, {})

let sourceFiles = program.getSourceFiles()

if (sourceFiles.length <= 1)
	error("File not found")

let typeChecker = program.getTypeChecker()

console.log("# Generated by dts2nim script")
console.log("# Source files:")
for (let sourceFile of sourceFiles) {
	console.log("#     " + sourceFile.fileName)
}

console.log()
console.log("when not defined(js) and not defined(Nimdoc):")
console.log("  {.error: \"This module only works on the JavaScript platform\".}")
console.log()

// Support

// Assume enum is a bitfield, print all relevant bits.
// If "tight", assume enum values are exact values, not masks.
function enumBitstring(Enum, value:number, tight = false) : string {
	let result = ""
	for (let key in Enum) {
		let bit = Enum[key]
		if (typeof bit != "number" || !bit) continue
		let masked = value&bit
		if (tight ? (masked==bit) : masked) {
			if (result) result += "+"
			result += key
		}
	}
	return result
}

// Are all bits in b set in a?
function hasBit(a:number, b:number) { return (a&b)==b }

// Raised on Typescript type the converter script doesn't know how to convert
class UnusableType extends Error {
	type: ts.Type
	constructor(type: ts.Type) {
		super("Cannot represent type: " + typeChecker.typeToString(type))
		this.type = type
	}
}

// Get Nim-source string corresponding to TypeScript type
function nimType(type: ts.Type) : string {
	if (type.flags & ts.TypeFlags.Number) // FIXME: Numberlike?
		return "float"
	if (type.flags & ts.TypeFlags.String) // FIXME: Stringlike?
		return "cstring"
	if (type.flags & ts.TypeFlags.Void)
		return "void"
	if ((type.flags & ts.TypeFlags.Class) && type.symbol)
		return type.symbol.name
	throw new UnusableType(type)
}

// Prints to stderr, suppressed if -q option given
let warn = commander.quiet ? function (...X) {} : console.warn.bind(console)

// Prefix `prefix` to every line of `string`, starting at line `startAtLine`
function linePrefix(str:string, prefix:string, startAtLine = 0) : string {
	let ary = str.split("\n")
	for (let idx in ary) {
		if (+idx >= startAtLine)
			ary[idx] = prefix + ary[idx]
	}
	return ary.join("\n")
}

// Return a string containing a commented-out string representation of an object,
// for tacking onto the end of an existing comment line
function debugVerboseEpilogue(obj:any) : string {
	if (!commander.debugVerbose)
		return ""
	return ", " + linePrefix(util.inspect(obj), "#         ", 1)
}

// Convert TypeScript identifier to legal Nim identifier
// FIXME: Leaves open possibility of collisions
function identifierScrub(id:string) : string {
	return id
		.replace(/_{2,}/, "_")
		.replace(/^_/, "")
}

// Print {.importc.} with possible symbol correction
function importDirective(id:string, cpp:boolean = false) {
	return "importc" + (cpp?"pp":"") + (id != identifierScrub(id) ? ":\"" + id + "\"" : "")
}

// Convert TypeScript symbol defining a function to a Nim source string
// If "owner" present, this is a method, otherwise it's a function
function translateProc(func: ts.Symbol, funcType: ts.Type, owner: ts.Symbol = null, ownerType: ts.Type = null) : string[] {
	let result = []
	let counter = 0
	for (let callSignature of funcType.getCallSignatures()) {
		try {
			let paramStrings = callSignature.getParameters().map(param =>
				""+identifierScrub(param.name) + ":" + nimType(typeChecker.getTypeOfSymbolAtLocation(param, sourceFile.endOfFileToken))
			)
			let returnTypeString = nimType(callSignature.getReturnType())
			if (owner) {
				// Notice nimType is not called. It seems certain this will break in some situation.
				let ownerTypeString = identifierScrub(owner.name)
				paramStrings = ["self:"+ownerTypeString].concat(paramStrings)
			}
			result.push("proc " + identifierScrub(func.name) + "*(" +
				paramStrings.join(", ") + "): " + returnTypeString +
				" {." + importDirective(func.name, !!owner) + ".}")
		} catch (e) {
			if (e instanceof UnusableType)
				warn("Could not translate " +
					(owner ?
						"method " +  func.name + " for class " + owner.name :
						"function " + func.name) +
					(counter > 0 ? ", call signature #" + counter : "") +
					" because tried to translate " + typeChecker.typeToString(funcType) +
					" but couldn't translate type " + typeChecker.typeToString(e.type)
				)
			else
				throw e
		}
		counter++
	}
	return result
}

// Emit symbols

let sourceFile = sourceFiles[sourceFiles.length-1]

for (let sym of typeChecker.getSymbolsInScope(sourceFile.endOfFileToken, 0xFFFFFFFF)) {
	let type = typeChecker.getTypeOfSymbolAtLocation(sym, sourceFile.endOfFileToken)
	
	// Handle --debugPrefix command
	if (commander.debugPrefix && sym.name.substr(0, commander.debugPrefix.length) == commander.debugPrefix)
		console.log("\n# " + sym.name + ": " + typeChecker.typeToString(type) +
			"\n#     Node:" + enumBitstring(ts.SymbolFlags, sym.flags, true) +
			debugVerboseEpilogue(sym) +
			"\n#     Type:" + enumBitstring(ts.TypeFlags, type.flags, true) +
			debugVerboseEpilogue(type)
		)

	// Variable
	if (hasBit(sym.flags, ts.SymbolFlags.BlockScopedVariable)) {
		try {
			let typeString = nimType(type)
			console.log("var " + identifierScrub(sym.name) + "* {." + importDirective(sym.name) + ", nodecl.}: "
				+ typeString)
		} catch (e) {
			if (e instanceof UnusableType)
				warn("Could not translate variable "+sym.name+" because couldn't translate type "+typeChecker.typeToString(e.type))
			else
				throw e
		}

	// Function
	} else if (hasBit(sym.flags, ts.SymbolFlags.Function)) {
		for (let str of translateProc(sym, type))
			console.log(str)
	
	// Class
	} else if (hasBit(sym.flags, ts.SymbolFlags.Class)) {
		let fields : string[] = []
		let methods: string[] = []

		// Iterate over class members
		// Public interface for SymbolTable lets you look up keys but not iterate them. CHEAT:
		for (let key in <any>sym.members) {
			let member = sym.members[key]
			let memberType = typeChecker.getTypeOfSymbolAtLocation(member, sourceFile.endOfFileToken)
			
			// Member is a constructor
			if (hasBit(member.flags, ts.SymbolFlags.Constructor)) {
				// Will handle separately
			
			// Member is a field
			} if (hasBit(member.flags, ts.SymbolFlags.Property)) {
				try {
					let typeString = nimType(memberType)
					fields.push(member.name + "*: " + typeString)
				} catch (e) {
					if (e instanceof UnusableType)
						warn("Could not translate property " + member.name + " on class " + sym.name +
							" because couldn't translate type " + typeChecker.typeToString(memberType)
						)
					else
						throw e
				}

			// Member is a method
			} else if (hasBit(member.flags, ts.SymbolFlags.Method)) {
				methods = methods.concat( translateProc(member, memberType, sym, type) )
			
			// Member is unsupported
			} else {
				warn("Could not figure out how to translate member", member.name, "of class", sym.name)
			}
		}

		// Get superclass
		// Neither "heritageClauses" nor "types" are exposed. CHEAT: 
		let heritageClauses = (<any>sym.declarations[0]).heritageClauses
		let inherit = heritageClauses ? heritageClauses[0].types[0].expression.text : null
		let inheritString = inherit ? inherit : "RootObj"

		console.log("type " + identifierScrub(sym.name) + "* {." + importDirective(sym.name) + ".} = ref object of " + inheritString +
			fields.map(field => "\n    " + field).join("") +
			methods.map(method => "\n" + method).join(""))

	// Unsupported
	} else {
		warn("Could not figure out how to translate symbol", sym.name, ":",
				typeChecker.typeToString(type))
	}
}
